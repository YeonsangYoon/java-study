package com.sist.main;
/*
 *    메모리구조(JVM)
 *    ------------------------------------------
 *     MethodArea, static => 컴파일러가 자종 저장
 *     method도 메모리에 저장
 *     void method() {
 *        구현부가 있어야 저장이 된다
 *     }
 *     => 메소드 선언만 된 경우에는 클래스를 저장하지 못한다 (미완성된 클래스)
 *        (추상클래스, 인터페이스) => 요구사항 분석
 *                   ------- 데이터베이스 연결, 윈도우, 네트워크 서버
 *                           웹구현 
 *        void method();
 *    ------------------------------------------
 *     Stack : LIFO(Last In First Out)
 *     지역변수, 매개변수 저장 => 메모리 자체에서 관리 (블록이 종료되면 사라짐)
 *    ------------------------------------------
 *     Heap : 동적메모리 할당 (new) => 객체변수, 배열(참조변수값)
 *    ------------------------------------------
 * 
 *    클래스
 *    ----
 *    1. 구성요소
 *       1) 변수
 *          = 인스턴스 변수 : 객체마다 메모리를 따로 저장
 *          = 정적(static) 변수 : 메모리 공간이 한개를 사용한다 (공유변수, 클래스변수)
 *             => 컴파일시 자동으로 생성
 *          = 지역변수 : 기능 처리에 필요한 데이터를 설정(메소드 종료와 동시에 사라진다)
 *          = 매개변수 : 메소드 호출 시 전달된값을 가지고 있는 변수
 *       2) 메소드 : 30% => 명령문의 집합 => 단락(구조적인 프로그램)
 *            추상메소드 : 설계 => 모든 개발자가 같은 메소드를 제어
 *                          => 표준화 작업
 *            종단메소드 : final void a() => 변경할 수 없는 메소드
 *       3) 생성자
 *          = 객체 생성시 호출되는 메소드
 *          = 맴버변수의 초기화
 *          = 클래스명과 동일
 *          = 리턴형이 없다
 *          = 생성자는 여러개 존재할 수 있다(오버로딩)
 *          = 클래스안에 생성자를 반드시 구현하는 것은 아니다
 *            -> 없으면 컴파일러가 기본 생성자를 만듬
 *        
 *       = 변수만 모아서 관리 : 사용자 정의 데이터형 (~VO, ~DTO, ~Bean)
 *       = 메소드만 모아서 관리 : 액션 클래스 (~System, ~DAO, ~Manager, ~Service)
 *    2. 클래스 설계
 *       1. 기능 설계 : 메소드 추출
 *       2. 기능에서 사용하는 변수 추출
 *       3. 클래스 설계
 *       4. 메모리 저장
 *       5. 활용
 *       6. 소멸
 *    3. 접근제어자
 *    4. 객체지향의 특성
 *       1) 캡슐화 => 데이터를 은닉화한후에 메소드를 통해서 접근 가능
 *                   ----------- private => getter/setter
 *       2) 재사용
 *           => 상속 (is-a) : 기존의 기능을 변경해서 사용
 *           => 포함 (has-a) : 기존의 기능을 있는 그대로 사용
 *       3) 수정, 추가 => 다형성
 *    5. 제어자
 */
public class 객체지향정리 {

}
